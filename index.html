<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TFT Profiles - IGN & Rank List</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
        }

        h1 {
            color: white;
            text-align: center;
            margin-bottom: 30px;
            font-size: 2.5rem;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.2);
        }

        .controls {
            text-align: center;
            margin-bottom: 30px;
        }

        .refresh-btn {
            background: white;
            color: #667eea;
            border: none;
            padding: 12px 30px;
            border-radius: 25px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        }

        .refresh-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.3);
        }

        .refresh-btn:active {
            transform: translateY(0);
        }

        .refresh-btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }

        .loading {
            text-align: center;
            color: white;
            font-size: 1.2rem;
            margin: 20px 0;
            display: none;
        }

        .loading.active {
            display: block;
        }

        .error {
            background: #fed7d7;
            color: #e53e3e;
            padding: 15px;
            border-radius: 10px;
            margin: 20px 0;
            display: none;
        }

        .error.active {
            display: block;
        }

        .profiles-grid {
            display: flex;
            flex-direction: column;
            gap: 20px;
            margin-top: 20px;
            overflow-y: auto;
            overflow-x: hidden;
            padding-right: 10px;
            -webkit-overflow-scrolling: touch;
        }

        .profiles-grid::-webkit-scrollbar {
            width: 8px;
        }

        .profiles-grid::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.1);
            border-radius: 4px;
        }

        .profiles-grid::-webkit-scrollbar-thumb {
            background: #667eea;
            border-radius: 4px;
        }

        .profiles-grid::-webkit-scrollbar-thumb:hover {
            background: #764ba2;
        }

        .profile-card {
            background: white;
            border-radius: 20px;
            padding: 0;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
            width: 100%;
            overflow: hidden;
            border: 1px solid rgba(0, 0, 0, 0.05);
        }

        .profile-card.loading {
            opacity: 0.6;
            pointer-events: none;
        }

        .profile-header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            padding: 15px 20px;
            color: white;
            display: flex;
            align-items: flex-start;
            gap: 15px;
        }

        .profile-icon {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.2);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.3rem;
            flex-shrink: 0;
        }

        .profile-header-info {
            flex: 1;
            min-width: 0;
        }

        .profile-header-games {
            flex-shrink: 0;
            min-width: 200px;
        }

        .ign {
            font-size: 1.1rem;
            font-weight: 600;
            margin: 0 0 8px 0;
            word-break: break-word;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .rank-value {
            font-size: 0.85rem;
            opacity: 0.95;
            font-weight: 600;
            background: rgba(255, 255, 255, 0.15);
            padding: 3px 10px;
            border-radius: 10px;
            display: inline-block;
            margin-bottom: 8px;
        }

        .header-stats {
            display: flex;
            gap: 12px;
            margin-top: 6px;
            flex-wrap: wrap;
        }

        .header-stat {
            font-size: 0.75rem;
            opacity: 0.9;
        }

        .header-stat-label {
            opacity: 0.8;
            margin-right: 4px;
        }

        .header-stat-value {
            font-weight: 600;
        }

        .profile-body {
            padding: 15px 20px;
        }

        .rank-details {
            display: grid;
            grid-template-columns: repeat(1, 1fr);
            gap: 10px;
            margin-bottom: 15px;
        }

        .detail-item {
            text-align: center;
            padding: 12px;
            background: #f7fafc;
            border-radius: 10px;
        }

        .detail-label {
            font-size: 0.7rem;
            color: #718096;
            margin-bottom: 6px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            font-weight: 600;
        }

        .detail-value {
            font-size: 1.3rem;
            font-weight: 700;
            color: #2d3748;
        }

        .games-history {
            margin-top: 0;
            padding-top: 0;
        }

        .games-history-title {
            font-size: 0.7rem;
            color: rgba(255, 255, 255, 0.9);
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 8px;
            font-weight: 600;
        }

        .games-list {
            display: flex;
            flex-direction: row;
            flex-wrap: wrap;
            justify-content: flex-start;
            gap: 4px;
            padding: 0;
        }

        .game-item {
            display: inline-flex;
        }

        .game-info {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 4px;
        }

        .placement-block {
            width: 32px;
            height: 32px;
            border-radius: 5px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 700;
            font-size: 0.9rem;
            color: white;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }

        .placement-block.green {
            background: #38a169;
        }

        .placement-block.yellow {
            background: #d69e2e;
        }

        .placement-block.orange {
            background: #dd6b20;
        }

        .placement-block.red {
            background: #e53e3e;
        }

        .game-meta {
            font-size: 0.7rem;
            color: #718096;
            margin-top: 4px;
        }

        .stats-summary {
            background: white;
            border-radius: 15px;
            padding: 20px;
            margin-bottom: 20px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
            text-align: center;
        }

        .stats-summary h2 {
            color: #2d3748;
            margin-bottom: 15px;
            font-size: 1.5rem;
        }

        .stats-grid {
            display: flex;
            flex-direction: row;
            justify-content: space-around;
            align-items: center;
            gap: 20px;
            flex-wrap: wrap;
        }

        .stat-item {
            padding: 10px;
            background: #f7fafc;
            border-radius: 10px;
        }

        .stat-label {
            font-size: 0.8rem;
            color: #718096;
            margin-bottom: 5px;
        }

        .stat-value {
            font-size: 1.5rem;
            font-weight: bold;
            color: #667eea;
        }

        /* AI Feature Styles */
        .settings-btn {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            color: white;
            border: none;
            padding: 12px 30px;
            border-radius: 25px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            margin-left: 10px;
            transition: transform 0.2s, box-shadow 0.2s;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        }

        .settings-btn:hover {
            transform: translateY(-2px);
        }

        .analyze-btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 0.8rem;
            font-weight: 600;
            cursor: pointer;
            margin-left: 10px;
            transition: transform 0.2s;
        }

        .analyze-btn:hover {
            transform: translateY(-2px);
        }

        .refresh-user-btn {
            background: linear-gradient(135deg, #48bb78 0%, #38a169 100%);
            color: white;
            border: none;
            padding: 6px 12px;
            border-radius: 15px;
            font-size: 0.75rem;
            font-weight: 600;
            cursor: pointer;
            margin-left: 8px;
            transition: transform 0.2s;
        }

        .refresh-user-btn:hover {
            transform: translateY(-2px);
        }

        .refresh-user-btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }

        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(5px);
        }

        .modal.active {
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .modal-content {
            background: white;
            border-radius: 20px;
            padding: 30px;
            max-width: 500px;
            width: 90%;
            max-height: 90vh;
            overflow-y: auto;
            position: relative;
        }

        .modal-content.large {
            max-width: 900px;
        }

        .close-btn {
            position: absolute;
            top: 15px;
            right: 20px;
            font-size: 2rem;
            cursor: pointer;
            color: #718096;
        }

        .close-btn:hover {
            color: #e53e3e;
        }

        .modal-title {
            font-size: 1.5rem;
            color: #2d3748;
            margin-bottom: 20px;
        }

        .form-group {
            margin-bottom: 15px;
        }

        .form-group label {
            display: block;
            font-weight: 600;
            margin-bottom: 8px;
            color: #2d3748;
        }

        .form-group input,
        .form-group select {
            width: 100%;
            padding: 12px;
            border: 2px solid #e2e8f0;
            border-radius: 10px;
            font-size: 1rem;
        }

        .form-group input:focus,
        .form-group select:focus {
            outline: none;
            border-color: #667eea;
        }

        .btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 12px 20px;
            border-radius: 10px;
            font-weight: 600;
            cursor: pointer;
            width: 100%;
            margin-top: 10px;
        }

        .btn:hover {
            transform: translateY(-2px);
        }

        .btn-secondary {
            background: #e2e8f0;
            color: #2d3748;
        }

        .api-status {
            padding: 10px;
            border-radius: 8px;
            margin-top: 10px;
            font-size: 0.9rem;
        }

        .api-status.connected {
            background: #c6f6d5;
            color: #276749;
        }

        .api-status.disconnected {
            background: #fed7d7;
            color: #c53030;
        }

        .match-options {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            margin: 15px 0;
        }

        .match-option {
            padding: 8px 16px;
            border: 2px solid #e2e8f0;
            border-radius: 20px;
            cursor: pointer;
            font-size: 0.9rem;
        }

        .match-option:hover {
            border-color: #667eea;
        }

        .match-option.active {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border-color: transparent;
        }

        .match-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(60px, 1fr));
            gap: 8px;
            max-height: 200px;
            overflow-y: auto;
            padding: 10px;
            background: #f7fafc;
            border-radius: 10px;
        }

        .match-grid-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 8px;
            border: 2px solid transparent;
            border-radius: 8px;
            cursor: pointer;
            background: white;
        }

        .match-grid-item:hover {
            border-color: #667eea;
        }

        .match-grid-item.selected {
            border-color: #667eea;
            background: #ebf4ff;
        }

        .match-grid-item .p {
            width: 28px;
            height: 28px;
            border-radius: 6px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 700;
            color: white;
            font-size: 0.8rem;
        }

        .match-grid-item .info {
            font-size: 0.6rem;
            color: #718096;
            margin-top: 4px;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 4px solid #e2e8f0;
            border-top-color: #667eea;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 20px auto;
        }

        @keyframes spin {
            to {
                transform: rotate(360deg);
            }
        }

        .analysis-result {
            line-height: 1.8;
            color: #2d3748;
        }

        .analysis-result h2 {
            color: #667eea;
            font-size: 1.2rem;
            margin: 20px 0 10px;
            padding-bottom: 8px;
            border-bottom: 2px solid #e2e8f0;
        }

        .analysis-result ul,
        .analysis-result ol {
            margin-left: 20px;
            margin-bottom: 15px;
        }

        .analysis-result li {
            margin-bottom: 8px;
        }

        .analysis-result strong {
            color: #764ba2;
        }

        .analysis-error {
            background: #fed7d7;
            color: #c53030;
            padding: 20px;
            border-radius: 10px;
            text-align: center;
        }

        .player-header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 20px;
        }
    </style>
</head>

<body>
    <div class="container">
        <h1>üéÆ</h1>

        <div class="controls">
            <button class="settings-btn" onclick="openSettings()">‚öôÔ∏è AI Settings</button>
        </div>

        <div class="loading" id="loading">Loading profiles...</div>
        <div class="error" id="error"></div>

        <div class="profiles-grid" id="profilesGrid"></div>
    </div>

    <!-- Settings Modal -->
    <div class="modal" id="settingsModal">
        <div class="modal-content">
            <span class="close-btn" onclick="closeSettings()">&times;</span>
            <h2 class="modal-title">‚öôÔ∏è AI Settings</h2>
            <div class="form-group">
                <label>Google Gemini API Key:</label>
                <input type="password" id="apiKeyInput" placeholder="Enter API key...">
                <p style="font-size:0.8rem;color:#718096;margin-top:8px;">Get free at: <a
                        href="https://aistudio.google.com/apikey" target="_blank" style="color:#667eea;">Google AI
                        Studio</a></p>
            </div>
            <button class="btn" onclick="saveApiKey()">üíæ Save API Key</button>
            <div id="apiStatus" class="api-status disconnected">‚ùå No API key</div>
            <hr style="margin:20px 0;border:none;border-top:2px solid #e2e8f0;">
            <div class="form-group">
                <label>AI Model:</label>
                <button class="btn btn-secondary" onclick="fetchModels()" style="margin-bottom:10px;">üîÑ Fetch
                    Models</button>
                <select id="modelSelect">
                    <option value="gemini-2.0-flash">gemini-2.0-flash</option>
                </select>
            </div>
            <button class="btn" onclick="saveModel()">üíæ Save Model</button>
        </div>
    </div>

    <!-- Analysis Modal -->
    <div class="modal" id="analysisModal">
        <div class="modal-content large">
            <span class="close-btn" onclick="closeAnalysis()">&times;</span>
            <h2 class="modal-title">üß† AI Analysis</h2>
            <div id="analysisContent"></div>
        </div>
    </div>

    <script>
        // Hardcoded list of IGNs
        // Format: { region, gameName, tagLine, displayName }
        const IGN_LIST = [
            {
                region: 'VN2',
                gameName: 'M%E1%BA%ADp%20M%C4%83m%20M%C4%83m', // M·∫≠p MƒÉm MƒÉm
                tagLine: 'Pici0',
                displayName: 'M·∫≠p MƒÉm MƒÉm#Pici0'
            },
            {
                region: 'VN2',
                gameName: 'Guen%20Mori', // Guen Mori
                tagLine: 'vn2',
                displayName: 'Guen Mori#vn2'
            },
            {
                region: 'VN2',
                gameName: 'Halcyon',
                tagLine: '1621',
                displayName: 'Halcyon#1621'
            },
            {
                region: 'VN2',
                gameName: 'Yuki%20Apollo', // Yuki Apollo
                tagLine: 'vn2',
                displayName: 'Yuki Apollo#vn2'
            },
            {
                region: 'VN2',
                gameName: 'Musashi%20Shao', // Musashi Shao
                tagLine: 'shao',
                displayName: 'Musashi Shao#shao'
            },
            {
                region: 'VN2',
                gameName: 'Nguy%E1%BB%87tTh%E1%BB%B1cAsura', // Nguy·ªátTh·ª±cAsura
                tagLine: '0211',
                displayName: 'Nguy·ªátTh·ª±cAsura#0211'
            },
            {
                region: 'VN2',
                gameName: 'Untitled', // Untitled
                tagLine: '0610',
                displayName: 'Untitled#0610'
            },
            {
                region: 'VN2',
                gameName: 'EthanDoan', // EthanDoan
                tagLine: '1212',
                displayName: 'EthanDoan#1212'
            }
        ];

        function buildApiUrl(ign) {
            return `https://api.metatft.com/public/profile/lookup_by_riotid/${ign.region}/${ign.gameName}/${ign.tagLine}?source=full_profile&tft_set=TFTSet16`;
        }

        function buildRefreshApiUrl(ign) {
            return `https://api.metatft.com/public/profile/refresh_by_riotid/${ign.region}/${ign.gameName}/${ign.tagLine}?tier=1`;
        }

        async function fetchProfile(ign, useRefresh = false) {
            try {
                let response;
                if (useRefresh) {
                    // Use POST refresh API
                    const apiUrl = buildRefreshApiUrl(ign);
                    response = await fetch(apiUrl, {
                        method: 'POST',
                        headers: {
                            'accept': 'application/json, text/plain, */*'
                        }
                    });
                } else {
                    // Use GET lookup API
                    const apiUrl = buildApiUrl(ign);
                    response = await fetch(apiUrl);
                }
                
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                const data = await response.json();
                profileDataStore[ign.displayName] = data; // Store for AI analysis
                return { success: true, data, ign };
            } catch (error) {
                return { success: false, error: error.message, ign };
            }
        }

        async function refreshUserProfile(ignDisplayName) {
            const ign = IGN_LIST.find(i => i.displayName === ignDisplayName);
            if (!ign) return;

            // Find the card and add loading state
            const cards = document.querySelectorAll('.profile-card');
            let targetCard = null;
            cards.forEach(card => {
                if (card.querySelector('.ign')?.textContent.includes(ignDisplayName.split('#')[0])) {
                    targetCard = card;
                }
            });

            if (targetCard) {
                targetCard.style.opacity = '0.6';
                targetCard.style.pointerEvents = 'none';
            }

            try {
                // Step 1: Call refresh API (POST)
                const refreshUrl = buildRefreshApiUrl(ign);
                const refreshResponse = await fetch(refreshUrl, {
                    method: 'POST',
                    headers: {
                        'accept': 'application/json, text/plain, */*'
                    }
                });

                if (!refreshResponse.ok) {
                    throw new Error(`Refresh failed: ${refreshResponse.status}`);
                }

                // Step 2: Wait a bit for the refresh to process, then fetch updated profile
                await new Promise(resolve => setTimeout(resolve, 1000)); // Wait 1 second

                // Step 3: Call profile lookup API (GET) to get updated data
                const result = await fetchProfile(ign, false); // Use lookup API
                
                if (result.success) {
                    // Replace the card with updated data
                    const profilesGrid = document.getElementById('profilesGrid');
                    const newCard = createProfileCard(result);
                    
                    // Find and replace the old card
                    const allCards = Array.from(profilesGrid.children);
                    const oldCardIndex = allCards.findIndex(card => 
                        card.querySelector('.ign')?.textContent.includes(ignDisplayName.split('#')[0])
                    );
                    
                    if (oldCardIndex !== -1) {
                        profilesGrid.replaceChild(newCard, allCards[oldCardIndex]);
                    }
                } else {
                    alert(`Error fetching updated profile for ${ignDisplayName}: ${result.error}`);
                }
            } catch (error) {
                alert(`Error refreshing ${ignDisplayName}: ${error.message}`);
            } finally {
                if (targetCard) {
                    targetCard.style.opacity = '1';
                    targetCard.style.pointerEvents = 'auto';
                }
            }
        }

        function createProfileCard(profileData) {
            const { data, ign } = profileData;
            const card = document.createElement('div');
            card.className = 'profile-card';

            const ignText = data.summoner?.riot_id || ign.displayName || 'N/A';
            const rankText = data.ranked?.rating_text || 'N/A';
            const numGames = data.ranked?.num_games || 0;
            const ratingNumeric = data.ranked?.rating_numeric || 0;
            const peakRating = data.ranked?.peak_rating || 'N/A';

            // Generate games history HTML with placement only from matches in first API
            let gamesHistoryHTML = '';
            if (data.matches && data.matches.length > 0) {
                const last20Matches = data.matches.slice(0, 20);
                gamesHistoryHTML = `
                    <div class="games-history">
                        <div class="games-history-title">Last 20 Games</div>
                        <div class="games-list">
                            ${last20Matches.map((match) => {
                    const placement = match.placement;
                    if (typeof placement !== 'number') return '';

                    let placementColor = 'red';
                    if (placement <= 2) {
                        placementColor = 'green';
                    } else if (placement <= 4) {
                        placementColor = 'yellow';
                    } else if (placement <= 6) {
                        placementColor = 'orange';
                    } else {
                        placementColor = 'red';
                    }

                    const date = match.game_datetime ? new Date(match.game_datetime) : null;
                    const dateStr = date ? date.toLocaleDateString('en-US', { month: 'short', day: 'numeric' }) : '';

                    return `
                                    <div class="game-item">
                                        <div class="game-info">
                                            <div class="placement-block ${placementColor}">
                                                ${placement}
                                            </div>
                                            ${dateStr ? `<div class="game-meta">${dateStr}</div>` : ''}
                                        </div>
                                    </div>
                                `;
                }).join('')}
                        </div>
                    </div>
                `;
            } else {
                gamesHistoryHTML = `
                    <div class="games-history">
                        <div class="games-history-title">Last 20 Games</div>
                        <div class="games-list" style="text-align: center; color: rgba(255, 255, 255, 0.7); padding: 10px 0; font-size: 0.7rem;">
                            No games
                        </div>
                    </div>
                `;
            }

            card.innerHTML = `
                <div class="profile-header">
                    <div class="profile-icon">üë§</div>
                    <div class="profile-header-info">
                        <div class="ign">${ignText} 
                            <button class="analyze-btn" onclick="showAnalysisSetup('${ign.displayName.replace(/'/g, "\\'")}')">ü§ñ AI</button>
                            <button class="refresh-user-btn" onclick="refreshUserProfile('${ign.displayName.replace(/'/g, "\\'")}')" title="Refresh profile">üîÑ</button>
                        </div>
                        <div class="rank-value">${rankText}</div>
                        <div class="header-stats">
                            <div class="header-stat">
                                <span class="header-stat-label">Games:</span>
                                <span class="header-stat-value">${numGames}</span>
                            </div>
                            <div class="header-stat">
                                <span class="header-stat-label">Rating:</span>
                                <span class="header-stat-value">${ratingNumeric}</span>
                            </div>
                        </div>
                    </div>
                    <div class="profile-header-games">
                        ${gamesHistoryHTML}
                    </div>
                </div>
            `;

            return card;
        }

        function createErrorCard(ign, error) {
            const card = document.createElement('div');
            card.className = 'profile-card';
            card.innerHTML = `
                <div class="profile-icon">‚ùå</div>
                <div class="ign">${ign.displayName}</div>
                <div class="rank-section">
                    <div class="rank-label">Error</div>
                    <div class="rank-value" style="color: #e53e3e; font-size: 1rem;">${error}</div>
                </div>
            `;
            return card;
        }

        function calculateStats(profiles) {
            const successful = profiles.filter(p => p.success && p.data);
            const total = successful.length;

            if (total === 0) {
                return {
                    totalProfiles: IGN_LIST.length,
                    avgRating: 0,
                    highestRank: '-',
                    totalGames: 0
                };
            }

            const ratings = successful
                .map(p => p.data.ranked?.rating_numeric)
                .filter(r => r !== undefined && r !== null);

            const avgRating = ratings.length > 0
                ? Math.round(ratings.reduce((a, b) => a + b, 0) / ratings.length)
                : 0;

            const highestRating = Math.max(...ratings, 0);
            const highestProfile = successful.find(p =>
                p.data.ranked?.rating_numeric === highestRating
            );
            const highestRank = highestProfile?.data.ranked?.rating_text || '-';

            const totalGames = successful.reduce((sum, p) =>
                sum + (p.data.ranked?.num_games || 0), 0
            );

            return {
                totalProfiles: IGN_LIST.length,
                avgRating,
                highestRank,
                totalGames
            };
        }

        function updateStats(profiles) {
            const stats = calculateStats(profiles);
            const totalProfilesEl = document.getElementById('totalProfiles');
            const avgRatingEl = document.getElementById('avgRating');
            const highestRankEl = document.getElementById('highestRank');
            const totalGamesEl = document.getElementById('totalGames');
            const statsSummaryEl = document.getElementById('statsSummary');

            if (totalProfilesEl) totalProfilesEl.textContent = stats.totalProfiles;
            if (avgRatingEl) avgRatingEl.textContent = stats.avgRating;
            if (highestRankEl) highestRankEl.textContent = stats.highestRank;
            if (totalGamesEl) totalGamesEl.textContent = stats.totalGames;
            if (statsSummaryEl) statsSummaryEl.style.display = 'block';
        }

        async function loadAllProfiles() {
            const loading = document.getElementById('loading');
            const error = document.getElementById('error');
            const profilesGrid = document.getElementById('profilesGrid');

            // Show loading state
            loading.classList.add('active');
            error.classList.remove('active');
            profilesGrid.innerHTML = '';

            try {
                // Fetch all profiles in parallel
                const profilePromises = IGN_LIST.map(ign => fetchProfile(ign));
                const results = await Promise.all(profilePromises);

                // Sort by ratingNumeric (highest first)
                results.sort((a, b) => {
                    const ratingA = a.success ? (a.data?.ranked?.rating_numeric || 0) : -1;
                    const ratingB = b.success ? (b.data?.ranked?.rating_numeric || 0) : -1;
                    return ratingB - ratingA; // Descending order
                });

                // Clear grid and add cards
                profilesGrid.innerHTML = '';

                results.forEach(result => {
                    let card;
                    if (result.success) {
                        card = createProfileCard(result);
                    } else {
                        card = createErrorCard(result.ign, result.error);
                    }
                    profilesGrid.appendChild(card);
                });

                loading.classList.remove('active');

            } catch (err) {
                console.error('Error loading profiles:', err);
                error.textContent = `Error: ${err.message}`;
                error.classList.add('active');
                loading.classList.remove('active');
            }
        }

        // Load profiles on page load
        window.addEventListener('DOMContentLoaded', () => {
            loadAllProfiles();
            updateApiStatus();
        });

        // ============================================
        // AI ANALYSIS FUNCTIONS
        // ============================================
        let profileDataStore = {};
        let currentPlayer = null;
        let selectedMatches = [];
        let analysisMode = 'all';

        const getApiKey = () => localStorage.getItem('gemini_api_key') || '';
        const getModel = () => localStorage.getItem('gemini_model') || 'gemini-2.0-flash';

        function openSettings() {
            document.getElementById('settingsModal').classList.add('active');
            updateApiStatus();
        }
        function closeSettings() { document.getElementById('settingsModal').classList.remove('active'); }
        function openAnalysis() { document.getElementById('analysisModal').classList.add('active'); }
        function closeAnalysis() {
            document.getElementById('analysisModal').classList.remove('active');
            currentPlayer = null;
            selectedMatches = [];
        }
        window.onclick = e => { if (e.target.classList.contains('modal')) e.target.classList.remove('active'); };

        function saveApiKey() {
            const key = document.getElementById('apiKeyInput').value.trim();
            if (key && !key.startsWith('‚Ä¢')) {
                localStorage.setItem('gemini_api_key', key);
                updateApiStatus();
                alert('‚úÖ Saved!');
            }
        }
        function saveModel() {
            const m = document.getElementById('modelSelect').value;
            if (m) { localStorage.setItem('gemini_model', m); alert('‚úÖ Saved: ' + m); }
        }
        function updateApiStatus() {
            const key = getApiKey();
            const status = document.getElementById('apiStatus');
            const input = document.getElementById('apiKeyInput');
            if (key) {
                status.className = 'api-status connected';
                status.innerHTML = '‚úÖ Connected';
                input.value = '‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢';
            } else {
                status.className = 'api-status disconnected';
                status.innerHTML = '‚ùå No API key';
            }
            document.getElementById('modelSelect').value = getModel();
        }
        async function fetchModels() {
            const key = getApiKey();
            if (!key) return alert('‚ùå Save API key first!');
            try {
                const res = await fetch(`https://generativelanguage.googleapis.com/v1beta/models?key=${key}`);
                const data = await res.json();
                if (data.error) throw new Error(data.error.message);
                const sel = document.getElementById('modelSelect');
                sel.innerHTML = '';
                data.models.filter(m => m.supportedGenerationMethods?.includes('generateContent')).forEach(m => {
                    const n = m.name.replace('models/', '');
                    const opt = document.createElement('option');
                    opt.value = n; opt.textContent = n;
                    if (n === getModel()) opt.selected = true;
                    sel.appendChild(opt);
                });
                alert('‚úÖ Loaded!');
            } catch (e) { alert('‚ùå ' + e.message); }
        }

        function showAnalysisSetup(displayName) {
            const data = profileDataStore[displayName];
            if (!data) return alert('‚ùå No data! Refresh first.');
            if (!getApiKey()) { alert('‚ùå Set API key first!'); return openSettings(); }

            currentPlayer = displayName;
            selectedMatches = [];
            analysisMode = 'all';

            const matches = data.matches || [];
            const name = data.summoner?.riot_id || displayName;
            const rank = data.ranked?.rating_text || 'Unranked';

            let gridHTML = '';
            matches.forEach((m, i) => {
                const p = m.placement;
                let c = '#e53e3e';
                if (p <= 2) c = '#38a169'; else if (p <= 4) c = '#d69e2e'; else if (p <= 6) c = '#dd6b20';
                const d = new Date(m.match_timestamp);
                gridHTML += `<div class="match-grid-item" data-idx="${i}" onclick="toggleMatch(${i})"><div class="p" style="background:${c}">${p}</div><div class="info">#${i + 1}</div></div>`;
            });

            document.getElementById('analysisContent').innerHTML = `
                <div class="player-header"><strong>${name}</strong> - ${rank} (${matches.length} games)</div>
                <div class="form-group"><label>Model:</label>
                    <select id="setupModel"><option value="${getModel()}">${getModel()}</option></select>
                </div>
                <label style="font-weight:600;">Select matches:</label>
                <div class="match-options">
                    <div class="match-option active" onclick="setMode('all',this)">All (max 20)</div>
                    <div class="match-option" onclick="setMode('top10',this)">Top 10</div>
                    <div class="match-option" onclick="setMode('select',this)">Select</div>
                </div>
                <div id="matchGridWrap" style="display:none;">
                    <div class="match-grid">${gridHTML}</div>
                    <p id="selectedCount" style="font-size:0.8rem;color:#667eea;margin-top:8px;">Selected: 0</p>
                </div>
                <button class="btn" onclick="startAnalysis()" style="margin-top:20px;">üöÄ Start Analysis</button>
            `;
            loadSetupModels();
            openAnalysis();
        }

        async function loadSetupModels() {
            try {
                const res = await fetch(`https://generativelanguage.googleapis.com/v1beta/models?key=${getApiKey()}`);
                const data = await res.json();
                if (data.models) {
                    const sel = document.getElementById('setupModel');
                    sel.innerHTML = '';
                    data.models.filter(m => m.supportedGenerationMethods?.includes('generateContent')).forEach(m => {
                        const n = m.name.replace('models/', '');
                        const opt = document.createElement('option');
                        opt.value = n; opt.textContent = n;
                        if (n === getModel()) opt.selected = true;
                        sel.appendChild(opt);
                    });
                }
            } catch (e) { }
        }

        function setMode(mode, el) {
            analysisMode = mode;
            selectedMatches = [];
            document.querySelectorAll('.match-option').forEach(e => e.classList.remove('active'));
            el.classList.add('active');
            document.getElementById('matchGridWrap').style.display = mode === 'select' ? 'block' : 'none';
            document.querySelectorAll('.match-grid-item').forEach(e => e.classList.remove('selected'));
            updateCount();
        }
        function toggleMatch(idx) {
            const el = document.querySelector(`.match-grid-item[data-idx="${idx}"]`);
            if (selectedMatches.includes(idx)) {
                selectedMatches = selectedMatches.filter(i => i !== idx);
                el.classList.remove('selected');
            } else {
                selectedMatches.push(idx);
                el.classList.add('selected');
            }
            updateCount();
        }
        function updateCount() {
            const el = document.getElementById('selectedCount');
            if (el) el.textContent = `Selected: ${selectedMatches.length}`;
        }

        function getMatchesToAnalyze(data) {
            const m = data.matches || [];
            if (analysisMode === 'top10') return m.slice(0, 10);
            if (analysisMode === 'select') return selectedMatches.map(i => m[i]).filter(Boolean);
            return m.slice(0, 20);
        }

        function buildPrompt(data, matches) {
            const stats = {
                count: matches.length,
                top4: matches.filter(m => m.placement <= 4).length,
                wins: matches.filter(m => m.placement === 1).length,
                avg: (matches.reduce((a, m) => a + m.placement, 0) / matches.length).toFixed(2)
            };
            
            // Ph√¢n t√≠ch chi ti·∫øt t·ª´ng tr·∫≠n v·ªõi c√°c giai ƒëo·∫°n
            const matchData = matches.map((m, i) => {
                const units = m.summary?.units?.map(u => ({ 
                    name: u.character_id.replace('TFT16_', ''), 
                    tier: u.tier, 
                    star_level: u.tier === 1 ? (u.rarity >= 3 ? 3 : u.rarity >= 2 ? 2 : 1) : 1, // Estimate star level
                    items: u.itemNames?.map(x => x.replace('TFT_Item_', '').replace('TFT16_Item_', '')) || []
                })) || [];
                
                // X√°c ƒë·ªãnh core champions (th∆∞·ªùng l√† tier 3-5 ho·∫∑c c√≥ items)
                const coreChamps = units.filter(u => u.tier >= 3 || (u.items && u.items.length >= 2));
                const itemHolders = units.filter(u => u.items && u.items.length > 0);
                
                // Ph√¢n t√≠ch upgrades (2-star, 3-star)
                const upgradedChamps = units.filter(u => {
                    // Champions c√≥ nhi·ªÅu items th∆∞·ªùng ƒë∆∞·ª£c upgrade
                    return (u.items && u.items.length >= 2) || u.tier >= 3;
                });
                
                // Ph√¢n t√≠ch giai ƒëo·∫°n early game (champ kh·ªüi ƒë·∫ßu) - Opener analysis
                const earlyChamps = units.filter(u => u.tier <= 2);
                const earlyTraits = m.summary?.traits?.filter(t => t.includes('TFT16_'))?.map(t => t.replace('TFT16_', '').split('_')[0]) || [];
                
                // X√°c ƒë·ªãnh opener type d·ª±a tr√™n early traits v√† champs
                let openerType = 'Unknown';
                if (earlyTraits.includes('Bilgewater') || earlyChamps.some(c => ['Illaoi', 'Graves', 'Twisted Fate', 'Gangplank'].includes(c.name))) {
                    openerType = 'Bilgewater Opener';
                } else if (earlyTraits.includes('Ionia') || earlyChamps.some(c => ['Briar', 'Jhin', 'Shen', 'Yasuo'].includes(c.name))) {
                    openerType = 'Ionia Opener';
                } else if (earlyTraits.includes('Demacia') || earlyChamps.some(c => ['Jarvan IV', 'Lulu', 'Sona', 'Neeko'].includes(c.name))) {
                    openerType = 'Demacia Opener';
                } else if (earlyTraits.includes('Noxus') || earlyChamps.some(c => ['Briar', 'Qiyana', 'Cho\'Gath', 'Sion'].includes(c.name))) {
                    openerType = 'Noxus Opener';
                } else if (earlyTraits.includes('Freljord') || earlyChamps.some(c => ['Anivia', 'Ashe', 'Sejuani'].includes(c.name))) {
                    openerType = 'Freljord Opener';
                } else if (earlyTraits.includes('Shadow Isles') || earlyChamps.some(c => ['Viego', 'Yorick'].includes(c.name))) {
                    openerType = 'Shadow Isles Opener';
                }
                
                // Ph√¢n t√≠ch upgrade path v√† timing
                const upgradeAnalysis = {
                    upgraded_core: upgradedChamps.map(c => ({ 
                        name: c.name, 
                        tier: c.tier, 
                        items: c.items,
                        upgrade_priority: c.items && c.items.length >= 2 ? 'High' : 'Medium'
                    })),
                    potential_3_stars: units.filter(u => u.tier <= 2 && u.items && u.items.length > 0).map(c => c.name),
                    upgrade_timing: m.summary?.level <= 7 ? 'Early upgrade' : m.summary?.level <= 8 ? 'Mid upgrade' : 'Late upgrade'
                };
                
                return {
                    game: i + 1, 
                    placement: m.placement,
                    round: m.summary?.last_round, 
                    level: m.summary?.level,
                    // Opener v√† champ kh·ªüi ƒë·∫ßu
                    opener: {
                        type: openerType,
                        starting_champs: earlyChamps.map(c => ({ name: c.name, tier: c.tier })),
                        early_traits: earlyTraits.slice(0, 4),
                        meta_alignment: openerType !== 'Unknown' ? 'C√≥ opener r√µ r√†ng' : 'Opener kh√¥ng r√µ'
                    },
                    // Giai ƒëo·∫°n ch·ªçn l√µi v√† n√¢ng c·∫•p
                    core_selection: {
                        core_champions: coreChamps.map(c => ({ name: c.name, tier: c.tier, items: c.items })),
                        item_distribution: itemHolders.map(h => ({ champ: h.name, items: h.items })),
                        core_traits: m.summary?.traits?.map(t => t.replace('TFT16_', '').split('_')[0]) || [],
                        upgrade_path: upgradeAnalysis
                    },
                    // Giai ƒëo·∫°n ch·ªët ƒë·ªôi h√¨nh
                    final_comp: {
                        all_units: units.map(u => ({ name: u.name, tier: u.tier, items: u.items })),
                        final_traits: earlyTraits,
                        level: m.summary?.level,
                        comp_strength: coreChamps.length >= 3 ? 'Strong' : coreChamps.length >= 2 ? 'Medium' : 'Weak'
                    },
                    // Transition analysis
                    transition: {
                        from_opener: openerType,
                        to_final: m.summary?.traits?.map(t => t.replace('TFT16_', '').split('_')[0]).join(', '),
                        smoothness: coreChamps.length > 0 && openerType !== 'Unknown' ? 'C√≥ transition' : 'Transition kh√¥ng r√µ'
                    }
                };
            });
            
            return `B·∫°n l√† chuy√™n gia TFT Challenger, coach c√≥ nhi·ªÅu nƒÉm kinh nghi·ªám ph√¢n t√≠ch gameplay s√¢u. Tham kh·∫£o meta t·ª´ TFTFlow.com (https://tftflow.com/) cho Set 16.1.

## THU·∫¨T NG·ªÆ: Econ, Slow roll, Fast 8, Fast 9, Pivot, Cap board, Spike, BIS, Item holder, Core selection, Transition, Itemization, Opener, Upgrade path

## META REFERENCE (TFTFlow Set 16.1):
- **AD Core Lines**: Bilgewater Opener, Ionia Opener, Fast 8 comps (Freljord Yunara, Bilgewater Flex, Slayers)
- **AP Core Lines**: Demacia Opener ‚Üí Fast 9 Arcanists, Noxus Opener ‚Üí Fast 9 Mel Flex, Freljord/Ixtal ‚Üí Fast 8
- **Key Strategies**: Bilgewater shop upgrades, Fast 9 transitions, Fast 8 top 4 lines
- **Opener Types**: Bilgewater (Illaoi/Graves/TF), Ionia (Briar/Jhin/Shen), Demacia (J4/Lulu/Sona), Noxus (Briar/Qiyana), Freljord (Anivia/Ashe)

## PLAYER: ${data.summoner?.riot_id || currentPlayer} (${data.ranked?.rating_text}) - ${data.ranked?.num_games} games

## STATS (${stats.count} games): Top4: ${((stats.top4 / stats.count) * 100).toFixed(1)}%, Avg: ${stats.avg}, Wins: ${stats.wins}

## MATCHES (v·ªõi ph√¢n t√≠ch giai ƒëo·∫°n chi ti·∫øt):\n${JSON.stringify(matchData, null, 2)}

## PH√ÇN T√çCH CHUY√äN S√ÇU (gi·ªØ nguy√™n t√™n champion, item, trait g·ªëc):

## üìä OVERVIEW\n[Ph√¢n t√≠ch playstyle t·ªïng th·ªÉ, ƒëi·ªÉm m·∫°nh/y·∫øu, so s√°nh v·ªõi meta TFTFlow]

## üéÆ OPENER & CHAMP KH·ªûI ƒê·∫¶U
Ph√¢n t√≠ch t·ª´ng tr·∫≠n:
- **Opener type**: C√≥ d√πng opener ƒë√∫ng theo meta kh√¥ng? (Bilgewater/Ionia/Demacia/Noxus/Freljord)
- **Opener quality**: Opener c√≥ ph√π h·ª£p v·ªõi items nh·∫≠n ƒë∆∞·ª£c kh√¥ng? (AD items ‚Üí Bilgewater/Ionia, AP items ‚Üí Demacia/Noxus)
- **Starting champions**: Champ kh·ªüi ƒë·∫ßu c√≥ ƒë√∫ng theo opener kh√¥ng? C√≥ gi·ªØ ƒë∆∞·ª£c winstreak/econ kh√¥ng?
- **Meta alignment**: So s√°nh v·ªõi TFTFlow - opener c√≥ theo ƒë√∫ng meta lines kh√¥ng?

## üéØ GIAI ƒêO·∫†N CH·ªåN L√ïI & N√ÇNG C·∫§P (CORE SELECTION & UPGRADES)
Ph√¢n t√≠ch t·ª´ng tr·∫≠n:
- **Core champions ƒë∆∞·ª£c ch·ªçn**: 
  * ƒê√°nh gi√° vi·ªác ch·ªçn l√µi c√≥ ph√π h·ª£p v·ªõi opener kh√¥ng?
  * C√≥ pivot ƒë√∫ng l√∫c t·ª´ opener sang core kh√¥ng?
  * Core c√≥ match v·ªõi meta lines t·ª´ TFTFlow kh√¥ng?
  
- **Upgrade Path & Timing**:
  * **Upgrade priority**: Champions n√†o ƒë∆∞·ª£c n√¢ng c·∫•p? C√≥ ƒë√∫ng priority kh√¥ng?
  * **2-star upgrades**: C√≥ n√¢ng c·∫•p ƒë√∫ng champs c·∫ßn thi·∫øt kh√¥ng? Timing c√≥ ƒë√∫ng kh√¥ng?
  * **3-star potential**: C√≥ c·ªë g·∫Øng 3-star champs n√†o kh√¥ng? C√≥ n√™n kh√¥ng? (Theo TFTFlow: m·ªôt s·ªë comps nh∆∞ Bilgewater c√≥ th·ªÉ aim Nautilus 3)
  * **Upgrade timing**: N√¢ng c·∫•p ·ªü level n√†o? C√≥ qu√° s·ªõm (·∫£nh h∆∞·ªüng econ) hay qu√° mu·ªôn (m·∫•t m√°u)?
  
- **Item distribution**: 
  * Items ƒë∆∞·ª£c g√°n cho ai? C√≥ BIS kh√¥ng?
  * Item holder c√≥ hi·ªáu qu·∫£ kh√¥ng? C√≥ transfer items ƒë√∫ng l√∫c kh√¥ng?
  * So s√°nh v·ªõi TFTFlow recommendations
  
- **Timing**: 
  * Ch·ªçn l√µi ·ªü round/level n√†o? 
  * C√≥ qu√° s·ªõm (ch∆∞a ƒë·ªß econ) hay qu√° mu·ªôn (m·∫•t qu√° nhi·ªÅu m√°u)?
  * Fast 8 vs Fast 9: C√≥ ch·ªçn ƒë√∫ng strategy kh√¥ng?

## üèÅ GIAI ƒêO·∫†N CH·ªêT ƒê·ªòI H√åNH (FINAL COMP)
Ph√¢n t√≠ch t·ª´ng tr·∫≠n:
- **Opener ‚Üí Final comp transition**: 
  * Qu√° tr√¨nh transition nh∆∞ th·∫ø n√†o? M∆∞·ª£t m√† hay g∆∞·ª£ng √©p?
  * C√≥ gi·ªØ ƒë∆∞·ª£c econ trong qu√° tr√¨nh transition kh√¥ng?
  * Transition c√≥ theo ƒë√∫ng meta lines t·ª´ TFTFlow kh√¥ng? (VD: Bilgewater ‚Üí Fast 8, Ionia ‚Üí Fast 9 Lucian Kindred)
  
- **Starting champions ‚Üí Final**: 
  * Champ kh·ªüi ƒë·∫ßu c√≥ ph√π h·ª£p ƒë·ªÉ build l√™n comp cu·ªëi kh√¥ng?
  * C√≥ gi·ªØ ƒë∆∞·ª£c champs t·ª´ opener kh√¥ng? Hay ph·∫£i pivot ho√†n to√†n?
  
- **Final board strength**: 
  * ƒê·ªôi h√¨nh cu·ªëi c√≥ ƒë·ªß m·∫°nh kh√¥ng? Thi·∫øu g√¨?
  * C√≥ ƒë·ªß upgrades kh√¥ng? (2-star core champs)
  * Items c√≥ optimal kh√¥ng?
  * So s√°nh v·ªõi meta comps t·ª´ TFTFlow

## üîç BOT 4 ANALYSIS (Ph√¢n t√≠ch s√¢u t·ª´ng tr·∫≠n 5-8)
V·ªõi m·ªói tr·∫≠n bot 4, ch·ªâ ra:
1. **Opener issues**: Opener sai? Kh√¥ng ph√π h·ª£p v·ªõi items? Kh√¥ng theo meta?
2. **Core selection**: Ch·ªçn l√µi sai? Upgrade sai priority? Timing sai?
3. **Upgrade problems**: N√¢ng c·∫•p qu√° s·ªõm/mu·ªôn? N√¢ng c·∫•p sai champs? Kh√¥ng n√¢ng c·∫•p ƒë·ªß?
4. **Transition issues**: Transition g∆∞·ª£ng √©p? M·∫•t econ? Pivot sai h∆∞·ªõng?
5. **Timing issues**: Econ, leveling, rolling c√≥ ƒë√∫ng kh√¥ng? Fast 8 vs Fast 9 decision sai?

## ‚ùå SAI L·∫¶M CH√çNH (T·ª´ data c·ª• th·ªÉ)
1. **[C·ª• th·ªÉ v·ªÅ opener]** - D·∫´n ch·ª©ng t·ª´ matches, so s√°nh v·ªõi TFTFlow meta
2. **[C·ª• th·ªÉ v·ªÅ core selection & upgrades]** - D·∫´n ch·ª©ng t·ª´ matches
3. **[C·ª• th·ªÉ v·ªÅ upgrade timing & priority]** - D·∫´n ch·ª©ng t·ª´ matches
4. **[C·ª• th·ªÉ v·ªÅ transition]** - D·∫´n ch·ª©ng t·ª´ matches  
5. **[Kh√°c]**

## ‚úÖ ƒêI·ªÇM M·∫†NH
- Opener t·ªët ·ªü tr·∫≠n n√†o? C√≥ theo ƒë√∫ng meta kh√¥ng?
- Core selection & upgrades t·ªët ·ªü tr·∫≠n n√†o?
- Transition m∆∞·ª£t ·ªü tr·∫≠n n√†o?
- Upgrade timing ƒë√∫ng ·ªü tr·∫≠n n√†o?

## üìö KEY TAKEAWAYS (Tips actionable d·ª±a tr√™n TFTFlow meta)
- **Opener selection**: C√°ch ch·ªçn opener ph√π h·ª£p v·ªõi items (AD ‚Üí Bilgewater/Ionia, AP ‚Üí Demacia/Noxus)
- **Core selection**: C√°ch ch·ªçn l√µi t·ª´ opener, khi n√†o pivot
- **Upgrade strategy**: 
  * Khi n√†o n√™n 2-star core champs
  * Khi n√†o aim 3-star (VD: Nautilus 3 trong Bilgewater)
  * Upgrade priority theo t·ª´ng comp
- **Transition tips**: C√°ch transition m∆∞·ª£t t·ª´ opener ‚Üí core ‚Üí final comp
- **Fast 8 vs Fast 9**: Khi n√†o n√™n Fast 8 (top 4), khi n√†o Fast 9 (win condition)
- **Itemization**: BIS items theo TFTFlow recommendations

## üéØ ROADMAP
- Target rank
- Focus areas (∆∞u ti√™n c·∫£i thi·ªán g√¨ tr∆∞·ªõc): Opener? Core selection? Upgrades? Transition?

## üí° COMP RECOMMENDATIONS (D·ª±a tr√™n TFTFlow meta)
D·ª±a tr√™n playstyle, ƒëi·ªÉm m·∫°nh/y·∫øu, v√† items th∆∞·ªùng nh·∫≠n ƒë∆∞·ª£c, recommend:
- **AD lines**: Bilgewater Opener, Ionia Opener, Fast 8 comps
- **AP lines**: Demacia/Noxus Opener ‚Üí Fast 9, Freljord/Ixtal Fast 8
- **Specific comps**: Recommend comps c·ª• th·ªÉ t·ª´ TFTFlow tier list ph√π h·ª£p v·ªõi player`;
        }

        async function callAPI(prompt, model) {
            const res = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/${model}:generateContent?key=${getApiKey()}`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ contents: [{ parts: [{ text: prompt }] }], generationConfig: { temperature: 0.7, maxOutputTokens: 4096 } })
            });
            const data = await res.json();
            console.log('API Response:', data);
            if (data.error) throw new Error(data.error.message);
            if (!data.candidates?.length) throw new Error('No response');
            const text = data.candidates[0]?.content?.parts?.find(p => p.text)?.text;
            if (!text) throw new Error('No text');
            return text;
        }

        function formatResult(text, name, rank, count) {
            let html = text.replace(/## (.*)/g, '<h2>$1</h2>').replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>').replace(/\n\n/g, '</p><p>').replace(/\n- /g, '</li><li>').replace(/\n(\d+)\. /g, '</li><li>');
            return `<button class="btn btn-secondary" onclick="showAnalysisSetup('${currentPlayer}')" style="margin-bottom:15px;">‚Üê Back</button>
                <div class="player-header"><strong>${name}</strong> - ${rank} (${count} games analyzed)</div>
                <div class="analysis-result"><p>${html}</p></div>`;
        }

        async function startAnalysis() {
            const data = profileDataStore[currentPlayer];
            const model = document.getElementById('setupModel')?.value || getModel();
            const matches = getMatchesToAnalyze(data);
            if (!matches.length) return alert('‚ùå Select at least 1 match!');

            const content = document.getElementById('analysisContent');
            content.innerHTML = `<div style="text-align:center;padding:40px;"><div class="spinner"></div><p>ü§ñ Analyzing ${matches.length} games...</p><p style="color:#718096;font-size:0.9rem;">Model: ${model}</p></div>`;

            try {
                const prompt = buildPrompt(data, matches);
                const result = await callAPI(prompt, model);
                const name = data.summoner?.riot_id || currentPlayer;
                const rank = data.ranked?.rating_text || 'Unranked';
                content.innerHTML = formatResult(result, name, rank, matches.length);
            } catch (e) {
                content.innerHTML = `<button class="btn btn-secondary" onclick="showAnalysisSetup('${currentPlayer}')">‚Üê Back</button><div class="analysis-error"><h3>‚ùå Error</h3><p>${e.message}</p></div>`;
            }
        }
    </script>
</body>

</html>